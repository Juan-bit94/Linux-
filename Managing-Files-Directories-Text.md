# Handling Files and Directories
- Files on a Linux system are stored within a single directory structure called a virtual directory.
- The virtual directory contains files from all the computer's storage devices and merges them into a single directory structure. This structure has a single base directory called the root directory, which is often simply called root.
- Often one of the first skills learned at the command line is how to navigate the virtual directory structure as well as how to create directories and remove them.
- Viewing files, creating them, copying and moving them, and deleting them are also important skills.
## Viewing and Creating Files
- The most basic command for viewing a file's name and its various metadata is the list (ls) command. Metadata is information that describes and provides additional details about data.
- To issue the list command, you type ls and any needed options or arguments. The basic syntax structure for the list command is:
  - ls [OPTION]... [FILE]...
- In the list command's syntax structure, [OPTION] means there are various options (also called switches) you can add to display different file metadata.
- The [FILE] argument shows that you can add a directory or filename to the commands end to look at metadata for either specific files or files within other virtual directory structure locations. Also optional.
- When you issue the ls command with no additional arguments or options, it displays all the files and subdorectories names within the present working directory
- The ls command's commonly used options
  - a: all, display all file and subdirectory names, including hidden files names.
  - d: directory, show a directory's own metadata instead of its contents.
  - F: classify, classify each file's type using an indicator code (*,/,=,>,@, or |)
  - i: inode, display all file and subdirectory names along with their associated index number.
  - l: this displays file and subdirectory metadata, which includes file types, file access permissions, hard link count, file owner, file's group, modification date and time, and filename.
  - R: show a directory's contents, and for any subdirectory within the original directory tree, consecutively show their contents as well (recursively).
- Be aware that some distributions include, by default, as alias for the ls -l command. It is ll.
- The touch command will allow you to create empty files on the fly. This command's primary purpose in life is to update a file's timestamps-access and modification. It is useful in that you can quickly create files with which to experiment.
- With touch command you can create a single file or multiple files at a time.
  - Example: touch file1.txt file2.txt file3.txt (this will create 3 files)
- Directories are sometimes called folders. From a user perspective, a directory contains files, but in reality a directory is a special file used to locate other files. A file for which the directory is responsible has some of its metadata stored within the directory file.
- This metadata includes the file's name along with the file's associated index (inode) number. Therefore, a file can be located via its managing directory.
- You can quickly create directories by using the mkdir command. The -F option on the ls command will help you in this endeavor. It displays any directories, including newly created ones, with a /indicator code following each directory's name.
- Be aware when building directories that a few problems can occur. Specifically this can happen when attempting to create a directory tree.
  - Use the following to avoid issues:
    - mkdir -p Projects/42/
    - This command mkdir with the option -p will allow the creation of sub directories.
- It is tedious to enter the ls -F command after each time you issue the mkdir command to ensure that the directory was built. Instead, use the -v option on the mkdir command to receive verification that the directory was successfully constructed.
## Copying and Moving Files
- Copying, moving, and renaming files and directories are essential skills. There are several nuances between the commands to complete these tasks that are important for you to know.
- To copy a file or directory locally, use the cp command. The basic syntax structure for the command is:
  - cp [OPTION]... SOURCE DEST
  - The source and destination are required.
  - Example: cp melodrama.txt 
- There are several useful cp command options.
  - a: archive, perform a recursive copy and keep all the files original attributes, such as permissions, ownership, and timestamps.
  - f: force, overwrite any preexisting destination files with the same name as DEST.
  - i: interactive, ask before overwriting any preexisting destination files with the same name as DEST.
  - n: no clobber, do not overwrite any preexisting destination files with the same name as DEST.
  - R, r: recursive, copy a directory's contents, and for any subdirectory within the original directory tree, consecutively copy its contents as well (recursive).
  - u: update, only overwrite preexisting destination files with the same name as DEST if the source file is newer.
  - v: verbose, provide detailed command action information as command executes.
- To move or rename a file or directory locally, you use a single command: mv. The command's basic syntax is nearly the same as the cp command:
  - mv [OPTION]... SOURCE DEST
- The commonly used mv command options are similar to cp command options.
  - f: force: Overwrite any preexisting destination files with the same name as DEST.
  - i: interactive: ask before overwriting any preexisting destination files with the same name as DEST.
  - n: no clobber,  do not overwrite any preexisting destination files with the same name as DEST.
  - u: update, only overwrite preexisting destination files with the same name as DEST if the source file is newer.
  - v: verbose, provide detailed command action information as the command executes.
- When renaming an entire directory, there are no additional required command options. Just issue the mv command as you would for renaming a file.
- You can move a file and rename it all in one simple mv command.
  - mv Emphasis/risk-taking.txt Story-Topics/risks.txt
- For lighting-fast copies of big files or when you are copying large groups of files, the remote sync utility is rather useful. This tool is often used to create backups, can securely copy files over a network, and is accessed via the rsync command.
- When you're copying files over a network to a remote host, the file transfer process typically needs protection via encryption methods. The rsync command can be tunneled through OpenSSH to provide data privacy. Also, the scp command can be employed to provide a secure file copy mechanism.
- To quickly copy a file locally, the rsync command syntax is similar to the mv command's syntax. It is as follows:
  - rsync [OPTION]... SOURCE DEST
- Certain rsync options will assist you in making quick file copies. Certain switches are helpful for copying large files or creating backups locally, so it's a good idea to review the commonly used rsync option.
  - a: archive: Use archive mode.
  - D: Retain device and special files.
  - g: group: Retain file's group.
  - h: human readable: Display any numeric output in human-readable format.
  - l: links: Copy symbolic links as symbolic links.
  - o: owner: Retain file's owner.
  - p: perms: Retain file's permissions
  - progress: Display progression of file copy process.
# Linking Files and Directories
- Understanding file and directory links is an essential part of your Linux journey. while many quickly pick up how to link files they do not necessarily understand the underlying link structure.
- There are two types of links. One is a symbolic link, which is also called a soft link. The other is a hard link, and we'll take a look at it first.
## Establish a Hard Link
- A hard link is a file or directory that has one index (inode) number but  at least two different filenames. Having a single inode number means that it is a single data file on the filesystem.
- Having two or more names means the file can be accessed in multiple ways. The hard link has two file names, one inode number, and therefore one filesystem location residing on a disk partition. Thus, the file has two names but is physically one file.
- A hard link allows you to have a pseudo-copy of a file without truly copying its data. This is often used in file backups where not enough filesystem space exists to backup the file's data. If someone deletes one of the file's names, you still have another filename that links to its data.
- To create a hard link, use theln command. For hard links, the original file must exist prior to issuing the ln command. The linked file must not exist. It is created when the command is issued.
- The inode numbers for the files can be checked using the ls -i command, and you can see that the numbers are the same for both files.
- If you want to remove a linked file but not the original file, use the unlink command. Just type unlink at the command line and include the linked filename as an argument.
- When creating and using hard links, there are a few important items to remember:
  - The original file must exist before you issue the ln command.
  - The second file listed in the ln command must not exist prior to issuing the command.
  - An original file and its hard links share the same inode number.
  - An original file and its hard links share the same data.
  - An original file and any of its hard links can exist in different directories.
  - An original file and its hard links must exist on the same filesystem.
## Constructing a Soft Link
- Typically, a soft link file provides a pointer to a file that may reside on another filesystem. The two files do not share inode numbers because they do not point to the same data.
- To create a symbolic link, the ln command is used with the -s option.
- You can see via the ls -i command that soft-linked files do not share the same inode number, unlike hard linked files. Also, soft-linked files do not experience a link count increase.
- Sometimes you have a soft-linked file that points to another soft-linked file. If you want to quickly find the final file, use the readlink -f command and pass one of the soft-linked filenames as an argument to it. The readlink utility will display the final file's name and directory location.
- When creating and using soft links, keep a few things in mind:
  - The original file must exist before you issue the ln -s command.
  - The second file listed in the ln -s command must not exist prior to issuing the command.
  - An original file and its soft links do not share the same inode number.
  - An original file and its soft links do not share the same data.
  - An original file and any of its soft links can exist in different directories.
  - An original file and its soft links can exist in different filesystems.
- Stale links can be a serious security problem. A stale link, sometimes called a dead link, is when a soft link points to a file that was deleted or moved. If a malicious file is put in the original file's place, your server's security could be compromised. Use symbolic links with caution and employ the unlink command if you need to remove a linked file.
# Reading Files
- Linux systems contain many text files. They include configuration files, log files, data files, and so on. Understanding how to view these files is a basic but important skill. 
## Reading Entire Text Files
- The basic utility for viewing entire text files is the concatenate (cat) command. 
- Use the cat command with the basic syntax:
  - cat [OPTION]... [FILE]...
- There is a handy new clone of the cat command called bat.
- Another useful command to view entire text files is the pr command. Its original use was to format text files for printing.
- To view a small text file, use pr command with the basic syntax:
  - pr [OPTION]... [FILE]...
  - The pr command's useful file display option
    - n, columns: Displays the file in cloumn format.
    - l n, length: Change the default 66-line page length to n lines long.
    - m, merge: When displaying multiple files, displays them in parallel, with one file in each column, and truncate the file lines.   
    - s, c, separator: Change the default column separator from tab to c.
    - t,omit header: Do not display any file header or trailers.
    - w, n: width: Change the default 72-character page width to n characters wide.
- There is a pr command that displays a file text as well.
    -  example: pr -tl numbers.txt
- Where the pr utility really shines is displaying two short text files at the same time. You can quickly view the files side by side.
    - example: pr -mtl 15 numbers.txt random.txt
- If yoy want to display two files side by side and do not care how sloppy the output is, you can use the paste command.
- When a text file is larger than your output screen, if you use commands such as cat and pr, text may scroll off the screen. Fortunately, there are several utilities that allow you to read portions of a text file.
## Reading Text File Portions
- If you just want to read a single file line or a small portion of a file, use the grep utility to help you find a file line(s) that contain certain text strings.
- The basic syntax for the grep command:
    - grep [OPTIONS] pattern [FILE...]
- When searching for a particular text string, you use the string for PATTERN in the command's syntax and the file you are searching as FILE.
- Example of using the grep command to find a file line
    - grep christine /etc/passwd
              -    or
    - grep -i christine /etc/passwd
- Be aware that the grep utility pays attention to case. If the string you enter does not match a string exactly within the file, the grep command will return nothing.
- If you employ the -i (or --ignore-case) switch, grep will search for any instance of the string disregarding case.
- Another handy tool for displaying portions of a text file is the head utility. The head command's syntax is as follows:
    - head [OPTION]... [FILE]...
- A good command option to try allows you to override the default behavior of only displaying a file's first 10 lines. The switch to use is either -n followed by an argument.
    - head -n 2 /etc/passwd
- Note that the -n 2 switch and argument used with the head command display only the file's first two line. You can also eliminate the file's bottom lines by using a negative argument with the -n switch
    - head -n -40 /etc/passwd
- If you want to display the file's last lines instead of its first lines, employ the tail utility. Its general syntax is similar to the head commands syntax
    - tail [OPTION]... [FILE]...
- One of the most useful tail utility features is its ability to watch log files. Log files typically have new messages appended to the file's bottom. Use the -f switch on the tail command and provide the log filename to watch as the command's argument. You will see a few recent log file entries immediately.
- Some log files have been replaced on various Linux distributions, and now the messages are kept in a journal file managed by journald. To watch messages being added to the journal file, use the journalctl --follow command.
- To end your monitoring session using tail, you must use the Control+C key combination.
    - example: sudo tail -f /var/log/auth.log
- To follow along, your Linux distribution may not have the /var/log/auth.log file. Try the /var/log/secure file instead.
## Reading Text File Pages
- One way to read through a large file's text is by using a pager. A pager utility allows you to view one text page at a time and move through the text at your own pace.  The two commonly used pagers are the more and less utilities
- The more utility is a nice little pager utility. You can move forward through a text file by pressing the spacebar or the Enter key. You cannot move backward through a file.
- A more flexible pager is the less utility. While similar to the more utility in that you can move through a file a page (or line) at a time, this pager utility also allows you to move backward.
- The less page utility allows faster file traversal because it does not read the entire file prior to displaying the file's first page. You can also employ the up and down arrow keys to traverse the file as well as the spacebar to move forward a page and the Esc+V key combination to move backward a page. You can search for a particular word within the file by pressing the ? key, typing in the word you want to find, and pressing Enter to search backward.
- You can replace ? with the / key to search forward. By default, the Linux man page utility uses less as its pager. Learning the less utility's commands will allow you to search through various man pages with ease.
# Finding Information
- There are many ways to find various types of information on your linux system.
## Viewing File Information
- It's not uncommon to look through a directory and see files you're not familiar with, or perhaps even forgot why they're there. Linux has a couple of handy commands that can help you out with that.
- The file command can provide basic information about the file type of a specified file.
    - example: file mystest
    - mytest: Bourne-Again shell script, ASCII text executable
- The output from the file command shows that Linux recognizes the mytest file as a shell script file, in ASCII text format, and as an executable file.
- If you'd like to see information about when a file was created, modified, or last accessed, use the stat command. 
    - example: stat mytest
- The stat command provides basic information about the file, such as the file's name, size, inode number, and the physical device it's stored on. It also provides harder-to-find information such as the last time the file was accessed and modified.
## Exploring File Differences
- A handy command to explore text file differences is the diff command. It allows you to make comparisons between two files. line by line. The basic syntax for the command is:
    - diff [OPTION]... FILES
- With the diff utility you can perform a veriety of comparisons. In addition, you can format the output to make the results easier for viewing.
- This table shows a few commonly used options.
      - e,--ed: Create an ed script, which can be used to make the first file compared the same as the second file compared.
      - q,--brief: If files are different, issue a simple message expressing this.
      - r, --recursive: Compare any subdirectories within the original directory tree, and consecutively compare their contents and the subdirectories as well (recursive).
      - s,--report-identical-files: If files are the same, issue a simple message expressing this.
      - w,--width n: Display a width maximum of n characters for output.
      - y,--side-by-side: Display output in two columns.
- The diff utility provides more than just differences; it also denotes what needs to be appended, changed, or deleted to make the first file identical to the second file. To see the exact differences between the files and any needed modifications, remove the -q switch.
- The diff command's output can be a little confusing. In the example, the first output line displays 2, 3c2, 3. This output tells you that to make the first file, numbers.txt, just like the second file, random.txt, you will need to change the numbers.txt file's lines 2 through 3 to match the random.txt file's lines 2 through 3. The output's next six lines show each file's text content that does not match, separated by a dashed line. Next, the 5c5 designates that line 5 in numbers.txt needs to be changed to match line 5 in the random.txt file.
- The letter c in the diff utility's output denotes that changes are needed. You may also see an a for any needed additions or d for any needed deletions.
## Using Simple Pinpoint Commands
- Commands that quickly locate (pinpoint) files are very useful. They allow you to determine if a particular utility is installed on your system, locate a needed configuration file, find helpful documentation, and so on.
- The which command shows you the full path name of a shell command passed as an argument.
    - example: which diff
    - /usr/bin/diff
- The which command is used to find the diff command's program location. The command displays the full path name of /usr/bin/diff.
- Note: Environment variables are configuration settings that modify your process's environment. When you type in a command (program) name, the PATH variable sets the directories Linux will search for the program binary. It is also used by other commands, such as the which utility. Note that directory names are separated by a colon(:) in the PATH list.
- The which command is also handy for quickly determining if a command is using an alias.
- Another simple pinpoint command is the whereis utility. This utility allows you to not only locate any command's program binaries but also locate source code files as well as any man pages.
    - Example: whereis diff
    - diff: /usr/bin/diff /usr/share/man/man1/diff.1.gz
    - /usr/share/man/man1p/diff.1p.gz
- The example above, the command issued searches for program binaries, source code files, and man pages for diff utility.
- A handy and simple utility to use in finding files is the locate program. This utility searches a database, mlocate.db, which is located in the var/lib/mlocate/ directory, to determine if a particular file exists on the local system. The basic syntax for the locate command is as follows:
      - locate [OPTION]... PATTERN...
- The locate command's commonly used options
    - A,--all: Display filenames that match all the patterns, instead of displaying files that match only one pattern in the pattern list.
    - b,--basename: Display only file names that match the pattern and do not include any directory names that match the pattern.
    - c,--count:  Display only the number of files whose name matches the pattern instead of displaying file names.
    - i,--ignore-case: Ignore case in the pattern for matching filenames.
    - q,--quiet: Do not display any error messages, such as permission denied, when processing.
    - r,--regexp R: Use the regular expression, R, instead of the pattern list to match filenames.
    - w,--wholename: Display filenames that match the pattern and include any directory names that match the pattern. This is default behavior.
- To find a file with the locate command, just enter locate followed by the filename. If the file is on your system and you have permission to view it, the locate utility will display the file's directory path and name.
- Using the locate command PATTERN can be a little tricky, due to default pattern file globbing. File globbing occurs when you use wildcards, such as an asterisk (*) or a question mark (?), added to a filename argument in a command, and the filename is expanded into multiple names.
- If you don't enter any wildcards into your pattern, the locate command, by default, adds wildcards to the pattern. SO if you enter the pattern, passwd, it is automatically turned into *passwd*. Thus if you just want to search for the base name passwd, with no file globbing, you must add quotation marks (single or double) around the pattern and precede the pattern and the \ character.
- Note: If you do not have permission to view a directory's contents, the locate command cannot show files that match your PATTERN, which are located in that directory. Thus, you may have some files missing from your display.
- Keep in mind that the locate command's PATTERN is really a pattern list. So, you can add additional patterns.
- Another problem you can run into deals with newly created or downloaded files. The locate utility is really searching the mlocate.db database as opposed to searching the virtual directory structure. This database is typically updated only one time per day via a cron job. Therefore, if the file is newly created, locate won't find it.
- The mlocate.db database is updated via the updatedb utility. You can run it manually using super privileges if you need to find a newly created or downloaded file.
## Using intricate Pinpoint Commands
- While using simple commands to locate files is useful, they don't work in situations where you need to find files based on things such as metadata.
- The find command is flexible. It allows you to locate files based on data, such as who owns the file, when the file was last modifiedm permission set on the file, and so on. The Basic command syntax is:
    - find [PATH...] [OPTION] [EXPRESSION]
- The PATH argument is a starting point directory, because you designate a starting point in a directory tree and find will search through that directory and all its subdirectories (recursively) for the file or files you seek. You can use a single period (.) to designate your present working directory as the starting point directory.
- Note: There are also options for the find command itself that handle such items as following or not following links and debugging. In addition, you can have a file deleted or a command executed if a particular file is located.
- The EXPRESSION command argument and its preceding OPTION control what type of metadata filters are applied to the search as well as any settings that may limit the search.
- The find utility has many features.
    - cmin, n: Display names of files whose status changed n minutes ago.
    - empty: Display names of files that are empty and are a regular text file or directory.
    - gif, n: Display names of files whose group id is equal to n.
    - group, name: Display names of files whose group is name.
    - inum, n: Display names of files whose inode number is equal to n.
    - maxdepth, n: When searching for files, traverse down into the starting point directory's tree only n levels.
    - mmin, n: Display names of files whose data changed n minutes ago.
    - name, pattern: Display names of files whose name matches pattern. Many regular expression arguments may be used in the pattern and need to be enclosed in quotation marks to avoid unpredictable results. Replace -name whith -iname to ignore case.
    - nogroup: Display names of files where no group name exists for the file's group ID.
    - nouser: Display names of files where no username exists for the file's user ID.
    - perm, mode: Display names of files whose permissions matches mode. Either octal or symbolic modes may be used.
    - size, n: Display names of files whose size matches n. Suffixes can be used to make the size more human readable such as G for gigabytes.
    - user, name: Display names of files whose owner is name.
- The find command is handy for auditing your system on a regular basis as well as when you are concerned that your server has been hacked. The -perm option is useful for one of these audit types.
- Earlier in this chapter we briefly covered the grep command for the purpose of reading a portion of a text file. You can also use this clever utility to search for files on your system.
- Support it has been a while since you last modified your /etc/nsswitch.conf configuration file. A problem arises that requires you to make a change to the host: setting within the file and you can't remember its exact name. Instead of digging around using the ls command, just employ the grep command
    - sudo grep -d skip hosts: /etc/*
    - /etc/nsswitch.conf:hosts:        files[...]
- The grep command is used to search all the files within the /etc/ directory for the hosts: setting. the -d skip option is used to skip any directory files in order to eliminate messages concerning them. The grep utility displays the configuration filename, followed by a colon (:) and the file's line where the setting is located. If you are not sure where in the /etc/ directory tree the configuration file is placed, you can tack on the -R (or -r, or --recursive) option to recursively search through the specified directory tree. If you don't have permission to search through various files, the grep command will issue annoying error messages.
## Summary
- Being able to effectively and swiftly use the right commands at the shell command line is important for your daily job. It allows you to solve problems, manage filesm gather information, persue text files and so on. 
